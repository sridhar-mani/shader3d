// Code Generator - WGSL IR to final WGSL string

import type { CompilerOptions, SourceMap, ShaderMetadata, Diagnostic } from './types';
import type { WGSLIR, WGSLFunction, WGSLStruct, WGSLUniform } from './transformer';

export interface CodeGenResult {
  code: string;
  sourceMap?: SourceMap;
  metadata: ShaderMetadata;
}

export interface CodeGenOptions {
  minify?: boolean;
  comments?: boolean;
  sourceMaps?: boolean;
  debugInfo?: boolean;
  indent?: string;
}

const DEFAULT_OPTIONS: CodeGenOptions = {
  minify: false,
  comments: true,
  sourceMaps: false,
  debugInfo: false,
  indent: '    ',
};

export class CodeGenerator {
  private options: CodeGenOptions;
  private output: string[] = [];
  private sourceMapEntries: Array<{ generated: number; original: number; name?: string }> = [];
  private currentLine = 1;

  constructor(options: Partial<CodeGenOptions> = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  generate(ir: WGSLIR): CodeGenResult {
    this.output = [];
    this.sourceMapEntries = [];
    this.currentLine = 1;

    // Header comment
    if (this.options.comments && !this.options.minify) {
      this.emit('// Generated by @shader3d/core');
      this.emit('// Do not edit directly');
      this.emit('');
    }

    // Emit structs first (dependencies may exist)
    for (const struct of ir.structs) {
      this.emitStruct(struct);
      if (!this.options.minify) this.emit('');
    }

    // Emit uniform bindings
    if (ir.uniforms.length > 0) {
      if (this.options.comments && !this.options.minify) {
        this.emit('// Uniforms');
      }

      // Group uniforms into a struct if there are multiple
      if (ir.uniforms.length > 1) {
        this.emitUniformStruct(ir.uniforms);
      } else {
        for (const uniform of ir.uniforms) {
          this.emitUniform(uniform);
        }
      }
      if (!this.options.minify) this.emit('');
    }

    // Emit helper functions first (non-entry points)
    const helpers = ir.functions.filter((f) => !f.isEntryPoint);
    const entryPoints = ir.functions.filter((f) => f.isEntryPoint);

    for (const fn of helpers) {
      this.emitFunction(fn);
      if (!this.options.minify) this.emit('');
    }

    // Emit entry points
    for (const fn of entryPoints) {
      this.emitFunction(fn);
      if (!this.options.minify) this.emit('');
    }

    let code = this.output.join(this.options.minify ? '' : '\n');

    // Minify if requested
    if (this.options.minify) {
      code = this.minifyCode(code);
    }

    // Build source map
    const sourceMap: SourceMap | undefined = this.options.sourceMaps
      ? {
          version: 3,
          file: 'shader.wgsl',
          sources: ['shader.ts'],
          names: [],
          mappings: this.generateSourceMapMappings(),
        }
      : undefined;

    // Build metadata
    const metadata: ShaderMetadata = this.buildMetadata(ir);

    return {
      code,
      sourceMap,
      metadata,
    };
  }

  private emit(line: string) {
    this.output.push(line);
    this.currentLine++;
  }

  private emitStruct(struct: WGSLStruct) {
    this.emit(`struct ${struct.name} {`);

    for (let i = 0; i < struct.fields.length; i++) {
      const field = struct.fields[i];
      const decorators = field.decorators.length > 0 ? field.decorators.join(' ') + ' ' : '';
      const comma = ''; // WGSL uses commas between fields
      this.emit(
        `${this.options.indent}${decorators}${field.name}: ${field.type}${i < struct.fields.length - 1 ? ',' : ''}`
      );
    }

    this.emit('}');
  }

  private emitUniformStruct(uniforms: WGSLUniform[]) {
    // Group all uniforms into a single struct for efficiency
    this.emit('struct Uniforms {');
    for (const uniform of uniforms) {
      this.emit(`${this.options.indent}${uniform.name}: ${uniform.type},`);
    }
    this.emit('}');
    this.emit('');
    this.emit('@group(0) @binding(0)');
    this.emit('var<uniform> uniforms: Uniforms;');
  }

  private emitUniform(uniform: WGSLUniform) {
    this.emit(`@group(${uniform.group}) @binding(${uniform.binding})`);
    this.emit(`var<uniform> ${uniform.name}: ${uniform.type};`);
  }

  private emitFunction(fn: WGSLFunction) {
    // Decorators
    for (const dec of fn.decorators) {
      this.emit(dec);
    }

    // Function signature
    const params = fn.params
      .map((p) => {
        const decorators = p.decorators.length > 0 ? p.decorators.join(' ') + ' ' : '';
        return `${decorators}${p.name}: ${p.type}`;
      })
      .join(', ');

    const returnType = fn.returnType && fn.returnType !== 'void' ? ` -> ${fn.returnType}` : '';
    this.emit(`fn ${fn.name}(${params})${returnType} {`);

    // Body
    for (const line of fn.body) {
      this.emit(`${this.options.indent}${line}`);
    }

    this.emit('}');
  }

  private minifyCode(code: string): string {
    return (
      code
        // Remove comments
        .replace(/\/\/.*$/gm, '')
        .replace(/\/\*[\s\S]*?\*\//g, '')
        // Remove excess whitespace
        .replace(/\s+/g, ' ')
        // Remove spaces around operators
        .replace(/\s*([{}\[\](),:;=+\-*/<>])\s*/g, '$1')
        // Add back necessary spaces
        .replace(/fn(\w)/g, 'fn $1')
        .replace(/var<(\w)/g, 'var<$1')
        .replace(/struct(\w)/g, 'struct $1')
        .replace(/return(\w)/g, 'return $1')
        .replace(/let(\w)/g, 'let $1')
        .replace(/if\(/g, 'if (')
        .replace(/for\(/g, 'for (')
        .replace(/while\(/g, 'while (')
        .trim()
    );
  }

  private generateSourceMapMappings(): string {
    // Generate VLQ-encoded source map mappings
    // This is a simplified implementation
    const mappings: string[] = [];
    let prevGenLine = 0;
    let prevOrigLine = 0;

    for (const entry of this.sourceMapEntries) {
      const genLineDelta = entry.generated - prevGenLine;
      const origLineDelta = entry.original - prevOrigLine;

      // Simplified: just track line numbers
      mappings.push(`A${this.vlqEncode(genLineDelta)}A${this.vlqEncode(origLineDelta)}`);

      prevGenLine = entry.generated;
      prevOrigLine = entry.original;
    }

    return mappings.join(';');
  }

  private vlqEncode(value: number): string {
    // Simplified VLQ encoding
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let result = '';
    let v = value < 0 ? (-value << 1) | 1 : value << 1;

    do {
      let digit = v & 0x1f;
      v >>= 5;
      if (v > 0) digit |= 0x20;
      result += chars[digit];
    } while (v > 0);

    return result;
  }

  private buildMetadata(ir: WGSLIR): ShaderMetadata {
    const bindings: Array<{ name: string; type: string; group: number; binding: number }> =
      ir.uniforms.map((u) => ({
        name: u.name,
        type: u.type,
        group: u.group,
        binding: u.binding,
      }));

    return {
      entryPoints: ir.entryPoints.map((e) => ({
        name: e.name,
        stage: e.stage,
      })),
      bindings,
      structs: ir.structs.map((s) => ({
        name: s.name,
        fields: s.fields.map((f) => ({ name: f.name, type: f.type })),
      })),
    };
  }
}

// Template-based generation for common patterns

export function generateFullscreenVertexShader(): string {
  return `
@vertex
fn fullscreen_vert(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
    // Generate fullscreen triangle
    let x = f32(vertex_index & 1u) * 4.0 - 1.0;
    let y = f32((vertex_index >> 1u) & 1u) * 4.0 - 1.0;
    return vec4<f32>(x, y, 0.0, 1.0);
}
`.trim();
}

export function generateUniformBuffer(
  name: string,
  fields: Array<{ name: string; type: string }>
): string {
  const fieldDefs = fields.map((f) => `    ${f.name}: ${f.type},`).join('\n');
  return `
struct ${name} {
${fieldDefs}
}

@group(0) @binding(0)
var<uniform> ${name.toLowerCase()}: ${name};
`.trim();
}

export function generate(ir: WGSLIR, options?: Partial<CodeGenOptions>): CodeGenResult {
  const generator = new CodeGenerator(options);
  return generator.generate(ir);
}
