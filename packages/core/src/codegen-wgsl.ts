import type {
  Shader3DAST,
  TypeDefinition,
  ShaderDefinition,
  Parameter,
  Attribute,
  TypeReference,
  Field,
  GlobalDeclaration
} from './ast'
import { BUILTIN_UNIFORMS } from './ast'

export interface WGSLCodeGenOptions {
  /** Include builtin uniforms (time, resolution, mouse) */
  builtinUniforms?: boolean
  /** Minify output */
  minify?: boolean
  /** Add debug comments */
  debug?: boolean
  /** Bind group for builtin uniforms */
  builtinGroup?: number
}

export class WGSLCodeGenerator {
  private options: WGSLCodeGenOptions
  private indentLevel = 0
  private output: string[] = []

  constructor(options: WGSLCodeGenOptions = {}) {
    this.options = {
      builtinUniforms: true,
      minify: false,
      debug: false,
      builtinGroup: 0,
      ...options
    }
  }

  generate(ast: Shader3DAST): string {
    this.output = []
    this.indentLevel = 0

    // Header comment
    if (this.options.debug) {
      this.emit('// Generated by Shader3D')
      this.emit(`// Source: ${ast.source?.filename || 'unknown'}`)
      this.emit('')
    }

    // 1. Generate builtin uniforms struct if needed
    if (this.options.builtinUniforms && this.hasShaders(ast)) {
      this.generateBuiltinUniforms()
    }

    // 2. Generate struct definitions
    if (ast.sharedTypes.length > 0) {
      ast.sharedTypes.forEach(type => {
        this.generateStruct(type)
        this.emit('')
      })
    }

    // 3. Generate global declarations (uniforms, storage buffers)
    if (ast.globals && ast.globals.length > 0) {
      ast.globals.forEach(global => {
        this.generateGlobal(global)
      })
      this.emit('')
    }

    // 4. Generate shader functions
    ast.gpuShaders.forEach((shader, index) => {
      if (index > 0) this.emit('')
      this.generateShader(shader)
    })

    return this.output.join('\n')
  }

  private hasShaders(ast: Shader3DAST): boolean {
    return ast.gpuShaders.length > 0
  }

  private generateBuiltinUniforms(): void {
    // Generate Shader3DUniforms struct
    this.emit('// Built-in uniforms (Shadertoy-compatible)')
    this.emit('struct Shader3DUniforms {')
    this.indentLevel++
    BUILTIN_UNIFORMS.forEach(uniform => {
      const typeStr = this.typeToWGSL(uniform.type)
      this.emit(`${uniform.name}: ${typeStr},`)
    })
    this.indentLevel--
    this.emit('}')
    this.emit('')

    // Generate uniform binding
    const group = this.options.builtinGroup
    this.emit(`@group(${group}) @binding(0) var<uniform> shader3d: Shader3DUniforms;`)
    this.emit('')
  }

  private generateStruct(type: TypeDefinition): void {
    this.emit(`struct ${type.name} {`)
    this.indentLevel++
    
    type.fields.forEach((field, index) => {
      const attrs = this.generateFieldAttributes(field)
      const typeStr = this.typeToWGSL(field.type)
      const comma = index < type.fields.length - 1 ? ',' : ','
      this.emit(`${attrs}${field.name}: ${typeStr}${comma}`)
    })
    
    this.indentLevel--
    this.emit('}')
  }

  private generateFieldAttributes(field: Field): string {
    if (!field.attributes || field.attributes.length === 0) {
      return ''
    }
    return field.attributes
      .map(attr => `@${attr.name}${attr.value ? `(${attr.value})` : ''} `)
      .join('')
  }

  private generateGlobal(global: GlobalDeclaration): void {
    const parts: string[] = []
    
    // Add group and binding attributes
    if (global.group !== undefined) {
      parts.push(`@group(${global.group})`)
    }
    if (global.binding !== undefined) {
      parts.push(`@binding(${global.binding})`)
    }
    
    // Address space and access mode
    let varDecl = 'var'
    if (global.addressSpace) {
      if (global.accessMode && global.addressSpace === 'storage') {
        varDecl = `var<${global.addressSpace}, ${global.accessMode}>`
      } else {
        varDecl = `var<${global.addressSpace}>`
      }
    }
    
    const typeStr = this.typeToWGSL(global.type)
    parts.push(`${varDecl} ${global.name}: ${typeStr};`)
    
    this.emit(parts.join(' '))
  }

  private generateShader(shader: ShaderDefinition): void {
    // Stage decorator
    this.emit(`@${shader.stage}`)

    // Workgroup size for compute shaders
    if (shader.stage === 'compute') {
      const size = shader.workgroupSize || [64]
      const sizeStr = size.filter(s => s !== undefined).join(', ')
      this.emit(`@workgroup_size(${sizeStr})`)
    }

    // Additional attributes
    shader.attributes.forEach(attr => {
      if (attr.name !== 'workgroup_size') {
        this.emit(`@${attr.name}${attr.value ? `(${attr.value})` : ''}`)
      }
    })

    // Function signature
    const params = this.generateParameters(shader.parameters)
    const returnType = shader.returnType 
      ? this.generateReturnType(shader.returnType)
      : ''

    this.emit(`fn ${shader.name}(${params})${returnType} {`)
    this.indentLevel++
    
    // Function body
    const body = this.convertBodyToWGSL(shader.body)
    body.split('\n').forEach(line => {
      if (line.trim()) {
        this.emit(line.trim())
      }
    })
    
    this.indentLevel--
    this.emit('}')
  }

  private generateParameters(params: Parameter[]): string {
    if (params.length === 0) return ''
    
    return params.map(param => {
      const attrs = param.attributes
        .map(attr => `@${attr.name}${attr.value !== undefined ? `(${attr.value})` : ''}`)
        .join(' ')
      
      const typeStr = this.typeToWGSL(param.type)
      const prefix = attrs ? `${attrs} ` : ''
      
      return `${prefix}${param.name}: ${typeStr}`
    }).join(', ')
  }

  private generateReturnType(returnType: { type: TypeReference; attributes: Attribute[] }): string {
    const attrs = returnType.attributes
      .map(attr => `@${attr.name}${attr.value !== undefined ? `(${attr.value})` : ''}`)
      .join(' ')
    
    const typeStr = this.typeToWGSL(returnType.type)
    
    if (attrs) {
      return ` -> ${attrs} ${typeStr}`
    }
    return ` -> ${typeStr}`
  }

  private typeToWGSL(type: TypeReference): string {
    switch (type.kind) {
      case 'primitive':
        return this.primitiveToWGSL(type.name)
      
      case 'vector':
        return `vec${type.size}<${type.elementType}>`
      
      case 'matrix':
        return `mat${type.rows}x${type.cols}<${type.elementType}>`
      
      case 'array':
        const elemType = this.typeToWGSL(type.elementType)
        return type.size !== undefined 
          ? `array<${elemType}, ${type.size}>`
          : `array<${elemType}>`
      
      case 'texture':
        if (type.sampleType) {
          return `${type.textureType}<${type.sampleType}>`
        }
        return type.textureType
      
      case 'sampler':
        return type.samplerType
      
      case 'pointer':
        if (type.accessMode) {
          return `ptr<${type.addressSpace}, ${this.typeToWGSL(type.elementType)}, ${type.accessMode}>`
        }
        return `ptr<${type.addressSpace}, ${this.typeToWGSL(type.elementType)}>`
      
      case 'custom':
        return type.name
      
      default:
        return 'f32'
    }
  }

  private primitiveToWGSL(name: string): string {
    const map: Record<string, string> = {
      'number': 'f32',
      'boolean': 'bool',
      'f32': 'f32',
      'i32': 'i32',
      'u32': 'u32',
      'bool': 'bool'
    }
    return map[name] || 'f32'
  }

  private convertBodyToWGSL(body: string): string {
    // Remove curly braces if present
    let cleaned = body.trim()
    if (cleaned.startsWith('{')) {
      cleaned = cleaned.slice(1)
    }
    if (cleaned.endsWith('}')) {
      cleaned = cleaned.slice(0, -1)
    }

    // TypeScript to WGSL conversions
    return cleaned
      // let -> var (WGSL uses var for mutable locals)
      .replace(/\blet\s+(?!mut\b)/g, 'var ')
      // const -> let (WGSL uses let for immutable)
      .replace(/\bconst\s+/g, 'let ')
      // Type annotations: : number -> : f32
      .replace(/:\s*number\b/g, ': f32')
      // Type annotations: : boolean -> : bool
      .replace(/:\s*boolean\b/g, ': bool')
      // Ternary operators: a ? b : c -> select(c, b, a)
      .replace(/(\w+)\s*\?\s*([^:]+)\s*:\s*([^;,)]+)/g, 'select($3, $2, $1)')
      // this.xxx -> xxx (for class methods converted to shaders)
      .replace(/\bthis\./g, '')
      // Math.sin -> sin, Math.cos -> cos, etc.
      .replace(/Math\.(sin|cos|tan|asin|acos|atan|sqrt|pow|abs|floor|ceil|round|min|max|exp|log|sign)/g, '$1')
      // Math.PI -> 3.14159265359
      .replace(/Math\.PI/g, '3.14159265359')
      // Math.random() -> Not supported, remove or warn
      .replace(/Math\.random\(\)/g, '/* random not supported in WGSL */')
      // .length -> arrayLength(&)
      .replace(/(\w+)\.length/g, 'arrayLength(&$1)')
      // Array indexing with [] is the same
      // for loop conversion
      .replace(/for\s*\(\s*let\s+(\w+)\s*=\s*0\s*;\s*\1\s*<\s*(\w+)(?:\.length)?\s*;\s*\1\s*\+\+\s*\)/g, 
        'for (var $1: u32 = 0u; $1 < $2; $1++)')
  }

  private emit(line: string): void {
    const indent = this.options.minify ? '' : '  '.repeat(this.indentLevel)
    this.output.push(indent + line)
  }
}

/**
 * Generate WGSL code from AST
 */
export function generateWGSL(ast: Shader3DAST, options?: WGSLCodeGenOptions): string {
  const generator = new WGSLCodeGenerator(options)
  return generator.generate(ast)
}

/**
 * Generate WGSL from source code directly
 */
export async function compileToWGSL(source: string, filename: string, options?: WGSLCodeGenOptions): Promise<string> {
  // Import here to avoid circular dependency
  const { parse } = await import('./parser')
  const ast = parse(source, filename)
  return generateWGSL(ast, options)
}
