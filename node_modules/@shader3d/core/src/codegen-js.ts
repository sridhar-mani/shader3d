import type {
  Shader3DAST,
  TypeDefinition,
  TypeReference
} from './ast'
import { BUILTIN_UNIFORMS } from './ast'

export interface JSCodeGenOptions {
  /** Output format: 'esm' | 'cjs' | 'iife' */
  format?: 'esm' | 'cjs' | 'iife'
  /** Include TypeScript types */
  typescript?: boolean
  /** Generate React hooks */
  react?: boolean
  /** Module name for IIFE format */
  moduleName?: string
  /** Embed WGSL as string or import from file */
  embedWGSL?: boolean
}

export class JSCodeGenerator {
  private options: JSCodeGenOptions
  private output: string[] = []

  constructor(options: JSCodeGenOptions = {}) {
    this.options = {
      format: 'esm',
      typescript: true,
      react: false,
      embedWGSL: true,
      ...options
    }
  }

  generate(ast: Shader3DAST, wgslCode: string): string {
    this.output = []

    // Header
    this.emit('// Generated by Shader3D - Do not edit directly')
    this.emit('')

    // Imports
    this.generateImports(ast)

    // Type exports (TypeScript only)
    if (this.options.typescript) {
      this.generateTypeExports(ast)
    }

    // Embedded WGSL
    if (this.options.embedWGSL) {
      this.generateEmbeddedWGSL(wgslCode)
    }

    // Uniform buffer helpers
    this.generateUniformHelpers(ast)

    // Pipeline factory functions
    this.generatePipelineFactories(ast)

    // React hooks (if enabled)
    if (this.options.react) {
      this.generateReactHooks(ast)
    }

    // Main exports
    this.generateExports(ast)

    return this.output.join('\n')
  }

  private generateImports(_ast: Shader3DAST): void {
    if (this.options.react) {
      this.emit("import { useEffect, useRef, useState, useCallback } from 'react';")
    }
    this.emit('')
  }

  private generateTypeExports(ast: Shader3DAST): void {
    // Generate TypeScript interfaces for shared types
    ast.sharedTypes.forEach(type => {
      this.emit(`export interface ${type.name} {`)
      type.fields.forEach(field => {
        const tsType = this.typeToTS(field.type)
        this.emit(`  ${field.name}: ${tsType};`)
      })
      this.emit('}')
      this.emit('')
    })

    // Generate uniform interface
    if (ast.gpuShaders.length > 0) {
      this.emit('export interface Shader3DUniforms {')
      BUILTIN_UNIFORMS.forEach(u => {
        const tsType = this.typeToTS(u.type)
        this.emit(`  /** ${u.description} */`)
        this.emit(`  ${u.name}: ${tsType};`)
      })
      this.emit('}')
      this.emit('')
    }
  }

  private generateEmbeddedWGSL(wgslCode: string): void {
    // Escape template literals
    const escaped = wgslCode.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$')
    this.emit('/**')
    this.emit(' * WGSL shader code')
    this.emit(' * @see https://www.w3.org/TR/WGSL/')
    this.emit(' */')
    this.emit(`export const shaderCode = \`${escaped}\`;`)
    this.emit('')
  }

  private generateUniformHelpers(ast: Shader3DAST): void {
    // Calculate byte sizes for structs
    ast.sharedTypes.forEach(type => {
      const byteSize = this.calculateByteSize(type)
      this.emit(`/** Byte size of ${type.name} struct (with proper alignment) */`)
      this.emit(`export const ${type.name}ByteSize = ${byteSize};`)
      this.emit('')

      // Generate struct writer function
      this.generateStructWriter(type)
    })

    // Builtin uniforms byte size
    this.emit('/** Byte size of Shader3D builtin uniforms */') 
    this.emit('export const Shader3DUniformsByteSize = 32; // time(4) + deltaTime(4) + frame(4) + pad(4) + resolution(8) + mouse(16)')
    this.emit('')

    // Helper to write builtin uniforms
    this.emit(`/**
 * Write Shader3D uniforms to a Float32Array
 * @param time - Elapsed time in seconds
 * @param deltaTime - Time since last frame
 * @param frame - Frame counter
 * @param resolution - Canvas size [width, height]
 * @param mouse - Mouse position [x, y, clickX, clickY]
 */
export function writeShader3DUniforms(
  buffer: Float32Array,
  time: number,
  deltaTime: number,
  frame: number,
  resolution: [number, number],
  mouse: [number, number, number, number]
): void {
  buffer[0] = time;
  buffer[1] = deltaTime;
  buffer[2] = frame;
  buffer[3] = 0; // padding
  buffer[4] = resolution[0];
  buffer[5] = resolution[1];
  buffer[6] = mouse[0];
  buffer[7] = mouse[1];
  buffer[8] = mouse[2];
  buffer[9] = mouse[3];
}`)
    this.emit('')
  }

  private generateStructWriter(type: TypeDefinition): void {
    this.emit(`/**`)
    this.emit(` * Write ${type.name} to a typed array at the given byte offset`)
    this.emit(` */`)
    this.emit(`export function write${type.name}(buffer: ArrayBuffer, offset: number, data: ${type.name}): void {`)
    this.emit(`  const view = new DataView(buffer, offset);`)
    
    let byteOffset = 0
    type.fields.forEach(field => {
      const { size, alignment } = this.getTypeInfo(field.type)
      // Align
      byteOffset = Math.ceil(byteOffset / alignment) * alignment
      
      this.emitFieldWriter(field, byteOffset)
      byteOffset += size
    })
    
    this.emit('}')
    this.emit('')
  }

  private emitFieldWriter(field: { name: string; type: TypeReference }, offset: number): void {
    const { type } = field
    
    switch (type.kind) {
      case 'primitive':
        if (type.name === 'f32' || type.name === 'number') {
          this.emit(`  view.setFloat32(${offset}, data.${field.name}, true);`)
        } else if (type.name === 'i32') {
          this.emit(`  view.setInt32(${offset}, data.${field.name}, true);`)
        } else if (type.name === 'u32') {
          this.emit(`  view.setUint32(${offset}, data.${field.name}, true);`)
        }
        break
      
      case 'vector':
        for (let i = 0; i < type.size; i++) {
          const components = ['x', 'y', 'z', 'w']
          this.emit(`  view.setFloat32(${offset + i * 4}, data.${field.name}.${components[i]}, true);`)
        }
        break
      
      case 'matrix':
        // Matrices are column-major
        for (let col = 0; col < type.cols; col++) {
          for (let row = 0; row < type.rows; row++) {
            const idx = col * type.rows + row
            this.emit(`  view.setFloat32(${offset + idx * 4}, data.${field.name}[${idx}], true);`)
          }
        }
        break
    }
  }

  private generatePipelineFactories(ast: Shader3DAST): void {
    // Group shaders by stage
    const computeShaders = ast.gpuShaders.filter(s => s.stage === 'compute')
    const vertexShaders = ast.gpuShaders.filter(s => s.stage === 'vertex')
    const fragmentShaders = ast.gpuShaders.filter(s => s.stage === 'fragment')

    // Compute pipeline factory
    computeShaders.forEach(shader => {
      this.emit(`/**`)
      this.emit(` * Create compute pipeline for ${shader.name}`)
      this.emit(` */`)
      this.emit(`export async function create${this.capitalize(shader.name)}Pipeline(device: GPUDevice): Promise<GPUComputePipeline> {`)
      this.emit(`  const module = device.createShaderModule({ code: shaderCode });`)
      this.emit(`  return device.createComputePipelineAsync({`)
      this.emit(`    layout: 'auto',`)
      this.emit(`    compute: {`)
      this.emit(`      module,`)
      this.emit(`      entryPoint: '${shader.name}'`)
      this.emit(`    }`)
      this.emit(`  });`)
      this.emit('}')
      this.emit('')
    })

    // Render pipeline factory (pairs vertex + fragment)
    if (vertexShaders.length > 0 && fragmentShaders.length > 0) {
      const vs = vertexShaders[0]
      const fs = fragmentShaders[0]
      
      this.emit(`/**`)
      this.emit(` * Create render pipeline with ${vs.name} and ${fs.name}`)
      this.emit(` */`)
      this.emit(`export async function createRenderPipeline(`)
      this.emit(`  device: GPUDevice,`)
      this.emit(`  format: GPUTextureFormat = navigator.gpu.getPreferredCanvasFormat()`)
      this.emit(`): Promise<GPURenderPipeline> {`)
      this.emit(`  const module = device.createShaderModule({ code: shaderCode });`)
      this.emit(`  return device.createRenderPipelineAsync({`)
      this.emit(`    layout: 'auto',`)
      this.emit(`    vertex: {`)
      this.emit(`      module,`)
      this.emit(`      entryPoint: '${vs.name}'`)
      this.emit(`    },`)
      this.emit(`    fragment: {`)
      this.emit(`      module,`)
      this.emit(`      entryPoint: '${fs.name}',`)
      this.emit(`      targets: [{ format }]`)
      this.emit(`    },`)
      this.emit(`    primitive: {`)
      this.emit(`      topology: 'triangle-list'`)
      this.emit(`    }`)
      this.emit(`  });`)
      this.emit('}')
      this.emit('')
    }
  }

  private generateReactHooks(_ast: Shader3DAST): void {
    this.emit(`/**`)
    this.emit(` * React hook for Shader3D WebGPU rendering`)
    this.emit(` */`)
    this.emit(`export function useShader3D(canvasRef: React.RefObject<HTMLCanvasElement>) {`)
    this.emit(`  const [device, setDevice] = useState<GPUDevice | null>(null);`)
    this.emit(`  const [error, setError] = useState<string | null>(null);`)
    this.emit(`  const [ready, setReady] = useState(false);`)
    this.emit(``)
    this.emit(`  useEffect(() => {`)
    this.emit(`    if (!canvasRef.current) return;`)
    this.emit(`    if (!navigator.gpu) {`)
    this.emit(`      setError('WebGPU not supported');`)
    this.emit(`      return;`)
    this.emit(`    }`)
    this.emit(``)
    this.emit(`    const init = async () => {`)
    this.emit(`      try {`)
    this.emit(`        const adapter = await navigator.gpu.requestAdapter();`)
    this.emit(`        if (!adapter) throw new Error('No GPU adapter');`)
    this.emit(`        const dev = await adapter.requestDevice();`)
    this.emit(`        setDevice(dev);`)
    this.emit(`        setReady(true);`)
    this.emit(`      } catch (e) {`)
    this.emit(`        setError(String(e));`)
    this.emit(`      }`)
    this.emit(`    };`)
    this.emit(``)
    this.emit(`    init();`)
    this.emit(`  }, [canvasRef]);`)
    this.emit(``)
    this.emit(`  return { device, error, ready };`)
    this.emit(`}`)
    this.emit('')
  }

  private generateExports(ast: Shader3DAST): void {
    const exports: string[] = ['shaderCode']
    
    // Add struct writers
    ast.sharedTypes.forEach(type => {
      exports.push(`${type.name}ByteSize`)
      exports.push(`write${type.name}`)
    })

    // Add pipeline factories
    ast.gpuShaders.forEach(shader => {
      if (shader.stage === 'compute') {
        exports.push(`create${this.capitalize(shader.name)}Pipeline`)
      }
    })

    if (ast.gpuShaders.some(s => s.stage === 'vertex') && 
        ast.gpuShaders.some(s => s.stage === 'fragment')) {
      exports.push('createRenderPipeline')
    }

    if (this.options.react) {
      exports.push('useShader3D')
    }

    // Default export with everything
    this.emit('/** Default export with all shader utilities */')
    this.emit('export default {')
    exports.forEach((exp, i) => {
      this.emit(`  ${exp}${i < exports.length - 1 ? ',' : ''}`)
    })
    this.emit('};')
  }

  private typeToTS(type: TypeReference): string {
    switch (type.kind) {
      case 'primitive':
        if (type.name === 'bool' || type.name === 'boolean') return 'boolean'
        return 'number'
      
      case 'vector':
        return `{ x: number; y: number${type.size >= 3 ? '; z: number' : ''}${type.size >= 4 ? '; w: number' : ''} }`
      
      case 'matrix':
        return `Float32Array`
      
      case 'array':
        const elem = this.typeToTS(type.elementType)
        return `${elem}[]`
      
      case 'custom':
        return type.name
      
      default:
        return 'unknown'
    }
  }

  private calculateByteSize(type: TypeDefinition): number {
    let size = 0
    let maxAlignment = 4

    type.fields.forEach(field => {
      const info = this.getTypeInfo(field.type)
      maxAlignment = Math.max(maxAlignment, info.alignment)
      // Align to field alignment
      size = Math.ceil(size / info.alignment) * info.alignment
      size += info.size
    })

    // Struct alignment: round up to largest member alignment
    return Math.ceil(size / maxAlignment) * maxAlignment
  }

  private getTypeInfo(type: TypeReference): { size: number; alignment: number } {
    switch (type.kind) {
      case 'primitive':
        return { size: 4, alignment: 4 } // f32, i32, u32 are all 4 bytes
      
      case 'vector':
        // vec2 = 8 bytes, vec3 = 12 (but aligned to 16), vec4 = 16
        const vecSize = type.size * 4
        const vecAlign = type.size === 2 ? 8 : 16
        return { size: vecSize, alignment: vecAlign }
      
      case 'matrix':
        // mat4x4 = 64 bytes, aligned to 16
        return { size: type.rows * type.cols * 4, alignment: 16 }
      
      case 'array':
        const elemInfo = this.getTypeInfo(type.elementType)
        const count = type.size || 1
        return { size: elemInfo.size * count, alignment: elemInfo.alignment }
      
      default:
        return { size: 4, alignment: 4 }
    }
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }

  private emit(line: string): void {
    this.output.push(line)
  }
}

/**
 * Generate JavaScript/TypeScript code from AST and WGSL
 */
export function generateJS(ast: Shader3DAST, wgslCode: string, options?: JSCodeGenOptions): string {
  const generator = new JSCodeGenerator(options)
  return generator.generate(ast, wgslCode)
}
